{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ONC Hydrophone Data","text":"<p>This site is the user\u2011focused documentation for onc-hydrophone-data: a toolkit to download ONC hydrophone spectrograms/audio and generate custom spectrograms locally.</p>"},{"location":"#what-you-can-do","title":"What you can do","text":"<ul> <li>Pull ONC spectrograms (MAT/PNG) for time ranges or sampled windows.</li> <li>Download FLAC/WAV audio for matching ranges.</li> <li>Run event\u2011based batches via JSON/CSV request files.</li> <li>Generate local custom spectrograms from audio with your own FFT parameters.</li> </ul>"},{"location":"#fast-download-model-oncside-parallelism","title":"Fast download model (ONC\u2011side parallelism)","text":"<p>This package submits multiple ONC data requests up front, then polls and downloads results as they complete. ONC processes those requests in parallel on their servers, which is much faster than submitting one request at a time and waiting for each to finish.</p> <p></p>"},{"location":"#recommended-path","title":"Recommended path","text":"<ol> <li>Quickstart for a minimal \u201cdownload + plot\u201d flow.</li> <li>Deployments &amp; Inventory to pick valid dates and devices.</li> <li>Downloads for the most common workflows.</li> <li>Custom Spectrograms for local generation.</li> </ol> <p>If you prefer notebooks, see <code>notebooks/ONC_Data_Download_Tutorial.ipynb</code> in the repo.</p>"},{"location":"custom_spectrograms/","title":"Custom Spectrograms","text":"<p>Use JSON request files to download audio clips and generate local spectrograms with your own parameters.</p> <pre><code>results = dl.create_custom_spectrograms_from_json(\n    \"/path/to/custom_requests.json\",\n    save_mat=True,\n    save_png=False,\n)\n</code></pre> <p>You can set <code>generator_defaults</code> and per\u2011request <code>generator_options</code> (e.g., <code>freq_lims</code>, <code>win_dur</code>, <code>overlap</code>) in the JSON.</p>"},{"location":"custom_spectrograms/#example-json","title":"Example JSON","text":"<pre><code>{\n  \"defaults\": {\n    \"deviceCode\": \"ICLISTENHF6324\",\n    \"pad_seconds\": 10\n  },\n  \"generator_defaults\": {\n    \"win_dur\": 0.5,\n    \"overlap\": 0.5\n  },\n  \"requests\": [\n    {\n      \"timestamp\": \"2024-04-01T12:30:00Z\",\n      \"generator_options\": {\n        \"freq_lims\": [10, 1000],\n        \"log_freq\": true\n      }\n    }\n  ]\n}\n</code></pre> <p>Tip</p> <p>When <code>freq_lims</code> is provided, saved outputs are cropped automatically. The downloader still pulls extra audio context to avoid edge artifacts.</p>"},{"location":"downloads/","title":"Download Workflows","text":"<p>Note</p> <p>The downloader submits multiple ONC requests in parallel and then downloads results as they become ready. ONC handles the parallel processing on its servers, so you don\u2019t need to parallelize locally.</p> <p></p>"},{"location":"downloads/#range-downloads-all-spectrograms-between-two-dates","title":"Range downloads (all spectrograms between two dates)","text":"<pre><code>result = dl.download_spectrograms_for_range(\n    device_code=DEVICE,\n    start_dt=start,\n    end_dt=end,\n    spectrograms_per_batch=6,\n)\n</code></pre>"},{"location":"downloads/#download-matching-audio","title":"Download matching audio","text":"<pre><code>result = dl.download_spectrograms_for_range(\n    device_code=DEVICE,\n    start_dt=start,\n    end_dt=end,\n    spectrograms_per_batch=6,\n    download_audio=True,\n)\n</code></pre>"},{"location":"downloads/#sampling-mode-uniform-samples-across-a-range","title":"Sampling mode (uniform samples across a range)","text":"<pre><code>result = dl.download_sampled_spectrograms(\n    device_code=DEVICE,\n    start_dt=start,\n    end_dt=end,\n    total_spectrograms=24,\n    spectrograms_per_request=6,\n)\n</code></pre>"},{"location":"downloads/#eventbased-downloads-simple-timestamps","title":"Event\u2011based downloads (simple timestamps)","text":"<pre><code>events = [\n    datetime(2024, 4, 1, 12, 5, tzinfo=timezone.utc),\n    datetime(2024, 4, 1, 13, 25, tzinfo=timezone.utc),\n]\nresult = dl.download_spectrograms_for_events(\n    device_code=DEVICE,\n    event_times=events,\n    spectrograms_per_request=6,\n)\n</code></pre>"},{"location":"downloads/#event-based-timestamps","title":"Event-based (timestamps)","text":"<pre><code>events = [datetime(2024, 4, 1, 12, 5, tzinfo=timezone.utc)]\nresult = dl.download_spectrograms_for_events(\n    device_code=DEVICE,\n    event_times=events,\n    spectrograms_per_request=6,\n)\n</code></pre>"},{"location":"downloads/#audio-only-range","title":"Audio-only range","text":"<pre><code>result = dl.download_audio_for_range(\n    device_code=DEVICE,\n    start_dt=start,\n    end_dt=end,\n)\n</code></pre>"},{"location":"downloads/#jsoncsv-request-files","title":"JSON/CSV request files","text":"<pre><code>results = dl.download_requests_from_json(\"/path/to/requests.json\")\nresults = dl.download_requests_from_csv(\"/path/to/requests.csv\")\n</code></pre>"},{"location":"downloads/#json-request-format","title":"JSON request format","text":"<p>JSON uses a <code>{defaults, requests}</code> payload. Each request must include <code>deviceCode</code> and either <code>timestamp</code> or a <code>start</code>/<code>end</code> window.</p> <pre><code>{\n  \"defaults\": {\n    \"pad_seconds\": 15,\n    \"download_audio\": true,\n    \"clip\": true,\n    \"data_product_options\": {\n      \"dpo_spectralDataDownsample\": 2\n    }\n  },\n  \"requests\": [\n    {\n      \"deviceCode\": \"ICLISTENHF6324\",\n      \"timestamp\": \"2024-04-01T12:34:50Z\",\n      \"label\": \"whale call 1\"\n    },\n    {\n      \"deviceCode\": \"ICLISTENHF6324\",\n      \"start\": \"2024-04-01T12:30:00Z\",\n      \"end\": \"2024-04-01T12:33:30Z\",\n      \"pad_before_seconds\": 10,\n      \"pad_after_seconds\": 20,\n      \"label\": \"ship noise event\"\n    }\n  ]\n}\n</code></pre>"},{"location":"downloads/#csv-request-format","title":"CSV request format","text":"<p>CSV is a flat table (one request per row) with the same fields as JSON. Use a <code>deviceCode</code> column to support multiple devices in one file.</p> <pre><code>deviceCode,timestamp,label,data_product_options\nICLISTENHF6324,2024-04-01T12:30:00Z,whale call,\"{\"\"dpo_spectralDataDownsample\"\": 2}\"\nICLISTENHF6324,2024-04-01T14:45:30Z,ship noise,\"{\"\"dpo_spectralDataDownsample\"\": 1}\"\nICLISTENHF6324,2024-04-02T08:15:00Z,unknown,\"\"\n</code></pre>"},{"location":"downloads/#supported-fields-json-csv","title":"Supported fields (JSON + CSV)","text":"Field Type Required Notes <code>deviceCode</code> string yes Hydrophone device code (e.g., <code>ICLISTENHF6324</code>) <code>timestamp</code> string if no <code>start</code>/<code>end</code> ISO 8601 (UTC or offset) <code>timezone</code> string no Timezone for naive timestamps (e.g., <code>America/Vancouver</code>, <code>UTC</code>, <code>-07:00</code>) <code>start</code> string if no <code>timestamp</code> ISO 8601 start time <code>end</code> string no ISO 8601 end time <code>duration_seconds</code> number no Used when <code>start</code> is set but <code>end</code> is omitted <code>pad_seconds</code> number no Symmetric padding around <code>timestamp</code> or <code>start</code> <code>pad_before_seconds</code> number no Override padding before <code>pad_after_seconds</code> number no Override padding after <code>download_audio</code> bool no Download audio files (default: false) <code>download_spectrogram</code> bool no Download ONC spectrograms (default: true) <code>spectrogram_format</code> string no <code>mat</code> or <code>png</code> <code>clip</code> bool no Clip outputs to the padded window <code>audio_extension</code> string no <code>flac</code> or <code>wav</code> <code>output_tag</code> string no Output folder tag <code>output_name</code> string no Override clip basename <code>label</code> / <code>description</code> string no Metadata label <code>data_product_options</code> object no ONC <code>dpo_*</code> options (same as <code>HSD_OPTIONS</code>)"},{"location":"downloads/#notes","title":"Notes","text":"<ul> <li>Multiple devices: include <code>deviceCode</code> per request/row.</li> <li>Timezone handling: timestamps are converted to UTC; provide tz-aware values or set <code>timezone</code>.</li> <li>Padding + clipping: padding can cross a 5\u2011minute boundary; the downloader fetches adjacent files and clips outputs.</li> <li>CSV JSON fields: <code>data_product_options</code> should be a JSON string in the CSV.</li> </ul>"},{"location":"downloads/#overriding-defaults","title":"Overriding defaults","text":"<p>You can override JSON defaults per call if needed:</p> <pre><code>results = dl.download_requests_from_json(\n    \"requests.json\",\n    default_pad_seconds=10,\n    download_audio=True,\n)\n</code></pre>"},{"location":"downloads/#batch-size-guidance","title":"Batch size guidance","text":"<ul> <li>6\u201312 spectrograms per request is usually a good balance.</li> <li>For large ranges, keep requests smaller to avoid timeouts.</li> </ul>"},{"location":"inventory/","title":"Deployments &amp; Inventory","text":"<p>Use the deployment inventory to pick devices and valid dates before downloading data.</p> <p></p> <pre><code>from onc_hydrophone_data.data.deployment_checker import HydrophoneDeploymentChecker\n\nchecker = HydrophoneDeploymentChecker(ONC_TOKEN)\ninventory = checker.collect_hydrophone_inventory()\n\n# Current deployments (active devices)\nchecker.show_hydrophone_inventory_table(inventory, view=\"current\")\n\n# Deployment history (all deployments)\nchecker.show_hydrophone_inventory_table(inventory, view=\"history\", max_rows=20)\n</code></pre> <p>Filter to specific devices after reviewing the tables:</p> <pre><code>checker.show_device_deployments(device_codes=[\"ICLISTENHF6324\"], inventory=inventory)\n# Or by numeric IDs if you have them:\n# checker.show_device_deployments(device_ids=[12345], inventory=inventory)\n</code></pre>"},{"location":"inventory/#visual-availability","title":"Visual availability","text":"<p>Get a deployment-aware view of data availability for a specific hydrophone:</p> <pre><code>from onc_hydrophone_data.data.deployment_checker import HydrophoneDeploymentChecker\nfrom onc_hydrophone_data.utils import (\n    plot_deployment_availability_timeline,\n    plot_availability_calendar,\n)\n\nchecker = HydrophoneDeploymentChecker(ONC_TOKEN)\navailability = checker.get_device_availability(\"ICLISTENHF6324\", bin_size=\"day\")\n\n# Timeline view (deployments on rows, data gaps highlighted)\nplot_deployment_availability_timeline(availability)\n\n# Calendar view (daily coverage heatmap)\nplot_availability_calendar(availability)\n\n# Convenience wrapper\n# checker.plot_device_availability(\"ICLISTENHF6324\", style=\"timeline\")\n</code></pre> <p>Note</p> <p>Availability uses ONC archive file listings, so long date ranges may take a while to query. Limit the date range or adjust <code>max_days_per_request</code> if needed.</p> <p>Tip</p> <p>The inventory tables already include deployment start/end dates, so you can choose valid time ranges directly from Table 1\u20133.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This is a minimal end\u2011to\u2011end example: load config, pick a device, and download a short window of spectrograms.</p> <pre><code>from datetime import datetime, timezone\nfrom onc_hydrophone_data.onc.common import load_config\nfrom onc_hydrophone_data.data.hydrophone_downloader import HydrophoneDownloader\n\nONC_TOKEN, DATA_DIR = load_config()\ndl = HydrophoneDownloader(ONC_TOKEN, DATA_DIR)\n\nDEVICE = \"ICLISTENHF6324\"\nstart = datetime(2024, 4, 1, 12, 0, tzinfo=timezone.utc)\nend = datetime(2024, 4, 1, 12, 10, tzinfo=timezone.utc)\n\nresult = dl.download_spectrograms_for_range(\n    DEVICE,\n    start,\n    end,\n    spectrograms_per_batch=2,\n)\nprint(result)\n</code></pre> <p>Note</p> <p>This call submits ONC requests up front and waits for data to become ready. ONC executes requests in parallel on their servers for faster throughput.</p> <p>If you want audio alongside spectrograms, add <code>download_audio=True</code>.</p> <pre><code>result = dl.download_spectrograms_for_range(\n    DEVICE,\n    start,\n    end,\n    spectrograms_per_batch=2,\n    download_audio=True,\n)\n</code></pre>"},{"location":"reference/","title":"API Reference (legacy entry)","text":"<p>The API reference is now organized under Reference \u2192 Overview in the docs navigation and split into module\u2011level pages.</p> <p>Start here: - Reference \u2192 Overview - Reference \u2192 HydrophoneDownloader - Reference \u2192 Deployment Checker - Reference \u2192 Spectrogram Generator - Reference \u2192 ONC Common Helpers</p>"},{"location":"reference/","title":"API Reference","text":"<p>The API reference is generated from docstrings and type hints. Use it to inspect all input arguments, defaults, and return values for user\u2011facing workflows.</p> <p>Start here: - HydrophoneDownloader for downloads and request files. - HydrophoneDeploymentChecker for deployment inventory and date ranges. - SpectrogramGenerator for local spectrogram creation. - ONC config helpers for loading tokens and formatting timestamps.</p>"},{"location":"reference/deployment_checker/","title":"HydrophoneDeploymentChecker","text":"<p>Check deployment dates and data availability for ONC hydrophones.</p> <p>Initialize the deployment checker.</p> <p>Parameters:</p> Name Type Description Default <code>onc_token</code> <code>str</code> <p>ONC API token</p> required <code>debug</code> <code>bool</code> <p>Enable debug logging</p> <code>False</code>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._archive_cache","title":"<code>_archive_cache = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._deployments_cache","title":"<code>_deployments_cache = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._deployments_cache_at","title":"<code>_deployments_cache_at = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._device_deployments_cache","title":"<code>_device_deployments_cache = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._device_deployments_cache_at","title":"<code>_device_deployments_cache_at = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._location_cache","title":"<code>_location_cache = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._location_cache_built","title":"<code>_location_cache_built = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._location_paths","title":"<code>_location_paths = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._location_paths_built","title":"<code>_location_paths_built = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.debug","title":"<code>debug = debug</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.onc","title":"<code>onc = ONC(onc_token, showInfo=debug, showWarning=debug)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._align_to_bin_start","title":"<code>_align_to_bin_start(dt_obj, bin_size)</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._build_location_cache","title":"<code>_build_location_cache()</code>","text":"<p>Build cache of location information and hierarchy paths.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._check_archive_availability_parallel","title":"<code>_check_archive_availability_parallel(device_codes, start_date, end_date, max_workers=10)</code>","text":"<p>Check archive file availability for multiple devices in parallel.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._check_product_availability_parallel","title":"<code>_check_product_availability_parallel(device_codes, max_workers=10)</code>","text":"<p>Check data product availability for multiple devices in parallel.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._coerce_datetime","title":"<code>_coerce_datetime(value, tz)</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._extract_archive_file_intervals","title":"<code>_extract_archive_file_intervals(archive_response)</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._fetch_archive_intervals","title":"<code>_fetch_archive_intervals(device_code, start_utc, end_utc, *, max_days_per_request=60, progress=None, quiet=True, max_workers=4, request_delay_seconds=0.0)</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._filter_inventory_by_devices","title":"<code>_filter_inventory_by_devices(inventory, *, device_codes=None, device_ids=None)</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._get_cached_deployments","title":"<code>_get_cached_deployments(max_age_minutes=30)</code>","text":"<p>Return cached deployments if fresh, otherwise fetch new ones.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._get_deployments_parallel","title":"<code>_get_deployments_parallel(hydrophones, max_workers=10)</code>","text":"<p>Fetch deployments for multiple hydrophones in parallel.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._get_device_deployments","title":"<code>_get_device_deployments(device_code, max_age_minutes=30)</code>","text":"<p>Fetch deployments for a single device (cached) for faster queries.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._iter_bins","title":"<code>_iter_bins(start_local, end_local, bin_size)</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._merge_intervals","title":"<code>_merge_intervals(intervals)</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._parse_deployment","title":"<code>_parse_deployment(deployment_dict)</code>","text":"<p>Parse a deployment dictionary into a DeploymentInfo object.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._parse_duration_seconds","title":"<code>_parse_duration_seconds(record)</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._parse_timestamp","title":"<code>_parse_timestamp(value)</code>","text":""},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker._resolve_display_location","title":"<code>_resolve_display_location(leaf_name, path)</code>","text":"<p>Decide which human-friendly location name to show. For array elements where the leaf is \"Hydrophone A/B/C...\", prefer the parent site name.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.check_data_availability","title":"<code>check_data_availability(deployments, start_date, end_date, check_archive=False)</code>","text":"<p>Check data availability for deployments in the specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>deployments</code> <code>List[DeploymentInfo]</code> <p>List of deployments to check</p> required <code>start_date</code> <code>datetime</code> <p>Start date for data availability check</p> required <code>end_date</code> <code>datetime</code> <p>End date for data availability check</p> required <code>check_archive</code> <code>bool</code> <p>If True, check for archive files, otherwise check data products</p> <code>False</code> <p>Returns:</p> Type Description <code>List[DeploymentInfo]</code> <p>List of deployments with data availability marked</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.collect_hydrophone_inventory","title":"<code>collect_hydrophone_inventory(*, include_inactive=True)</code>","text":"<p>Collect hydrophone deployment inventory with current and history views.</p> <p>Parameters:</p> Name Type Description Default <code>include_inactive</code> <code>bool</code> <p>If True, include inactive devices in the per\u2011device summaries when building the inventory.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with <code>current</code> and <code>history</code> lists of records.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.find_best_deployments_for_date_range","title":"<code>find_best_deployments_for_date_range(start_date, end_date, timezone_str='UTC', min_coverage_days=1)</code>","text":"<p>Find the best deployments that cover a specific date range.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>Union[str, datetime]</code> <p>Desired start date</p> required <code>end_date</code> <code>Union[str, datetime]</code> <p>Desired end date</p> required <code>timezone_str</code> <code>str</code> <p>Timezone for date interpretation</p> <code>'UTC'</code> <code>min_coverage_days</code> <code>int</code> <p>Minimum days of coverage required</p> <code>1</code> <p>Returns:</p> Type Description <code>List[DeploymentInfo]</code> <p>List of best deployments sorted by coverage quality</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.find_deployments_by_time_range","title":"<code>find_deployments_by_time_range(start_date, end_date, timezone_str='UTC')</code>","text":"<p>Find deployments that overlap with a specific time range.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>Union[str, datetime]</code> <p>Start date (string or datetime)</p> required <code>end_date</code> <code>Union[str, datetime]</code> <p>End date (string or datetime)</p> required <code>timezone_str</code> <code>str</code> <p>Timezone for date interpretation</p> <code>'UTC'</code> <p>Returns:</p> Type Description <code>List[DeploymentInfo]</code> <p>List of deployments that overlap with the time range</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.get_all_hydrophone_deployments","title":"<code>get_all_hydrophone_deployments()</code>","text":"<p>Get all hydrophone deployments from ONC.</p> <p>Returns:</p> Type Description <code>List[DeploymentInfo]</code> <p>List of <code>DeploymentInfo</code> objects for all deployments, including</p> <code>List[DeploymentInfo]</code> <p>location metadata (name/code, lat/lon, depth) and deployment dates.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.get_deployment_date_ranges","title":"<code>get_deployment_date_ranges(device_codes=None)</code>","text":"<p>Get deployment date ranges for specific device codes or all hydrophones.</p> <p>Parameters:</p> Name Type Description Default <code>device_codes</code> <code>Optional[List[str]]</code> <p>Optional list of device codes to check. If None, checks all.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, List[Tuple[datetime, Optional[datetime]]]]</code> <p>Dict mapping device codes to lists of <code>(start_date, end_date)</code> tuples.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.get_device_availability","title":"<code>get_device_availability(device_code, *, start_date=None, end_date=None, timezone_str='UTC', bin_size='day', max_days_per_request=60, progress=None, quiet=True, max_workers=4, request_delay_seconds=0.0)</code>","text":"<p>Build deployment-aware availability bins for a specific device.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str</code> <p>ONC device code to evaluate.</p> required <code>start_date</code> <code>Optional[Union[str, datetime]]</code> <p>Optional start date for availability window.</p> <code>None</code> <code>end_date</code> <code>Optional[Union[str, datetime]]</code> <p>Optional end date for availability window.</p> <code>None</code> <code>timezone_str</code> <code>str</code> <p>Timezone for binning and display.</p> <code>'UTC'</code> <code>bin_size</code> <code>str</code> <p>\"day\" or \"hour\" binning for availability.</p> <code>'day'</code> <code>max_days_per_request</code> <code>int</code> <p>Chunk size for archive queries.</p> <code>60</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with device metadata, deployments, bins, and deployment_summary.</p> <code>Dict[str, Any]</code> <p>Bin records include: start, end, coverage (0-1), status, deployment_index.</p> <code>Dict[str, Any]</code> <p>Bins align to day/hour boundaries in the requested timezone.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.plot_device_availability","title":"<code>plot_device_availability(device_code, *, start_date=None, end_date=None, timezone_str='UTC', bin_size='day', max_days_per_request=60, style='timeline', **plot_kwargs)</code>","text":"<p>Plot availability for a device using timeline or calendar styles.</p> <p>Parameters:</p> Name Type Description Default <code>device_code</code> <code>str</code> <p>ONC device code to evaluate.</p> required <code>start_date</code> <code>Optional[Union[str, datetime]]</code> <p>Optional start date for availability window.</p> <code>None</code> <code>end_date</code> <code>Optional[Union[str, datetime]]</code> <p>Optional end date for availability window.</p> <code>None</code> <code>timezone_str</code> <code>str</code> <p>Timezone for binning and display.</p> <code>'UTC'</code> <code>bin_size</code> <code>str</code> <p>\"day\" or \"hour\" binning for availability.</p> <code>'day'</code> <code>max_days_per_request</code> <code>int</code> <p>Chunk size for archive queries.</p> <code>60</code> <code>style</code> <code>str</code> <p>\"timeline\" or \"calendar\" (calendar requires bin_size='day').</p> <code>'timeline'</code> <code>plot_kwargs</code> <code>Any</code> <p>Passed to plotting helper.</p> <code>{}</code> <p>Returns:</p> Type Description <p>Matplotlib (fig, ax) tuple.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.print_deployment_summary","title":"<code>print_deployment_summary(deployments, show_data_availability=True)</code>","text":"<p>Print a formatted summary of deployments.</p> <p>Parameters:</p> Name Type Description Default <code>deployments</code> <code>List[DeploymentInfo]</code> <p>List of deployments to summarize</p> required <code>show_data_availability</code> <code>bool</code> <p>Whether to show data availability status</p> <code>True</code>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.render_hydrophone_inventory_table","title":"<code>render_hydrophone_inventory_table(inventory, *, view='current', max_rows=50)</code>","text":"<p>Render the inventory into a table (DataFrame if pandas is available).</p> <p>Parameters:</p> Name Type Description Default <code>inventory</code> <code>Dict[str, Any]</code> <p>Output of <code>collect_hydrophone_inventory</code>.</p> required <code>view</code> <code>str</code> <p><code>current</code> or <code>history</code>.</p> <code>'current'</code> <code>max_rows</code> <code>Optional[int]</code> <p>Maximum number of rows to display (None = no limit).</p> <code>50</code> <p>Returns:</p> Type Description <p>A pandas DataFrame if pandas is installed, otherwise a Markdown string.</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.show_device_deployments","title":"<code>show_device_deployments(*, device_codes=None, device_ids=None, max_rows=50, inventory=None)</code>","text":"<p>Show deployment history for specific device codes or device IDs.</p> <p>Parameters:</p> Name Type Description Default <code>device_codes</code> <code>Optional[List[str]]</code> <p>List of ONC device codes to filter by.</p> <code>None</code> <code>device_ids</code> <code>Optional[List[Union[str, int]]]</code> <p>List of numeric device IDs to filter by.</p> <code>None</code> <code>max_rows</code> <code>Optional[int]</code> <p>Maximum number of rows to display (None = no limit).</p> <code>50</code> <code>inventory</code> <code>Optional[Dict[str, Any]]</code> <p>Optional inventory output to reuse (avoids re-fetch).</p> <code>None</code> <p>Returns:</p> Type Description <p>The rendered table (DataFrame or Markdown string).</p>"},{"location":"reference/deployment_checker/#onc_hydrophone_data.data.deployment_checker.HydrophoneDeploymentChecker.show_hydrophone_inventory_table","title":"<code>show_hydrophone_inventory_table(inventory, *, view='current', max_rows=50)</code>","text":"<p>Display the inventory table in notebooks or print a Markdown fallback.</p> <p>Parameters:</p> Name Type Description Default <code>inventory</code> <code>Dict[str, Any]</code> <p>Output of <code>collect_hydrophone_inventory</code>.</p> required <code>view</code> <code>str</code> <p><code>current</code> or <code>history</code>.</p> <code>'current'</code> <code>max_rows</code> <code>Optional[int]</code> <p>Maximum number of rows to display (None = no limit).</p> <code>50</code> <p>Returns:</p> Type Description <p>The rendered table (DataFrame or Markdown string).</p>"},{"location":"reference/downloader/","title":"HydrophoneDownloader","text":"<p>User-facing downloader for ONC hydrophone data.</p> <p>This class bundles the most common workflows: - Range downloads for spectrograms and audio - Sampling and event-based downloads - JSON/CSV request files - Custom spectrogram generation</p> <p>Initialize the downloader.</p> <p>Parameters:</p> Name Type Description Default <code>ONC_token</code> <p>ONC API token.</p> required <code>parent_dir</code> <p>Root directory for downloads.</p> required <code>use_logging</code> <code>bool</code> <p>If True, use module logger; otherwise print to stdout.</p> <code>True</code> <code>spectral_downsample</code> <code>int</code> <p>Default HSD downsample setting (0=full, 1=1\u2011min, 2=plotRes).</p> <code>2</code> <code>**kwargs</code> <p>Reserved for future options.</p> <code>{}</code>"},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader._cache_timestamp","title":"<code>_cache_timestamp = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader._deployment_cache","title":"<code>_deployment_cache = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader._onc_token","title":"<code>_onc_token = ONC_token</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader._path_lock","title":"<code>_path_lock = Lock()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.audio_path","title":"<code>audio_path = os.path.join(self.parent_dir, 'audio', '')</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.deployment_checker","title":"<code>deployment_checker = DeploymentChecker(self._onc_token)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.flac_path","title":"<code>flac_path = self.audio_path</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.input_path","title":"<code>input_path = self.spectrogram_path</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.logger","title":"<code>logger = logger if use_logging else PrintLogger()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.max_workers","title":"<code>max_workers = 4</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.onc","title":"<code>onc = hd.ONC(ONC_token)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.parent_dir","title":"<code>parent_dir = parent_dir</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.request_manager","title":"<code>request_manager = ONCRequestManager(ONC_token, parent_dir, self.logger, spectral_downsample=spectral_downsample, spectrogram_concatenation='None')</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.spectral_downsample","title":"<code>spectral_downsample = spectral_downsample</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.spectrogram_path","title":"<code>spectrogram_path = os.path.join(self.parent_dir, 'onc_spectrograms', '')</code>  <code>instance-attribute</code>","text":""},{"location":"reference/downloader/#onc_hydrophone_data.data.hydrophone_downloader.HydrophoneDownloader.set_spectral_downsample","title":"<code>set_spectral_downsample(value)</code>","text":"<p>Override default downsample option (0=fullRes, 1=one-minute, 2=plotRes, etc.).</p>"},{"location":"reference/onc_common/","title":"ONC Common Helpers","text":""},{"location":"reference/onc_common/#onc_hydrophone_data.onc.common.STATUS_PREFIX","title":"<code>STATUS_PREFIX = {'INFO': '\u2139\ufe0f ', 'SUCCESS': '\u2705 ', 'WARNING': '\u26a0\ufe0f ', 'ERROR': '\u274c ', 'PROGRESS': '\ud83d\udd04 '}</code>  <code>module-attribute</code>","text":""},{"location":"reference/onc_common/#onc_hydrophone_data.onc.common.ensure_timezone_aware","title":"<code>ensure_timezone_aware(dt_obj, tz=timezone.utc)</code>","text":"<p>Convert timezone-naive datetime to timezone-aware datetime (and normalize to tz).</p> <p>Also handles date objects by converting them to datetime at midnight.</p>"},{"location":"reference/onc_common/#onc_hydrophone_data.onc.common.format_iso_utc","title":"<code>format_iso_utc(dt_obj)</code>","text":"<p>Format datetime as ONC-compatible ISO UTC string.</p>"},{"location":"reference/onc_common/#onc_hydrophone_data.onc.common.load_config","title":"<code>load_config(data_dir_override=None)</code>","text":"<p>Load ONC token and data directory from environment/.env.</p>"},{"location":"reference/onc_common/#onc_hydrophone_data.onc.common.print_status","title":"<code>print_status(message, level='INFO')</code>","text":"<p>Print a status message with level indicator.</p>"},{"location":"reference/onc_common/#onc_hydrophone_data.onc.common.start_and_end_strings","title":"<code>start_and_end_strings(start_date_object, time_delta)</code>","text":"<p>Calculate end date and return formatted start/end strings.</p>"},{"location":"reference/spectrogram_generator/","title":"SpectrogramGenerator","text":"<p>Generate spectrograms from audio files with configurable parameters. Based on MATLAB spectrogram computation with normalization and dB conversion.</p> <p>Initialize spectrogram generator with parameters from MATLAB code.</p> <p>Parameters:</p> Name Type Description Default <code>win_dur</code> <code>float</code> <p>Window duration in seconds (controls FFT size: NFFT = win_dur * fs)</p> <code>1.0</code> <code>overlap</code> <code>float</code> <p>Overlap ratio between adjacent windows (0-1), higher = smoother time axis</p> <code>0.5</code> <code>window_type</code> <code>Union[str, Tuple[str, float], ndarray]</code> <p>Window function name/tuple for scipy.signal.get_window (e.g., 'hann', ('kaiser', 14))          Custom arrays or unsupported window types fall back to the SciPy backend.</p> <code>'hann'</code> <code>nfft</code> <code>Optional[int]</code> <p>FFT size in samples (None = derived from win_dur/sample_rate)</p> <code>None</code> <code>win_length</code> <code>Optional[int]</code> <p>Window length in samples (None = use nfft)</p> <code>None</code> <code>hop_length</code> <code>Optional[int]</code> <p>Step size in samples (None = derived from overlap ratio)</p> <code>None</code> <code>freq_lims</code> <code>Tuple[float, float]</code> <p>Frequency limits for plotting [Hz] (and cropping if crop_freq_lims=True)</p> <code>(10, 10000)</code> <code>colormap</code> <code>str</code> <p>Matplotlib colormap name</p> <code>'turbo'</code> <code>clim</code> <code>Tuple[float, float]</code> <p>Color axis limits [dB]</p> <code>(-60, 0)</code> <code>log_freq</code> <code>bool</code> <p>Whether to use logarithmic frequency scale</p> <code>True</code> <code>crop_freq_lims</code> <code>bool</code> <p>If True, crop saved outputs to freq_lims</p> <code>False</code> <code>max_duration</code> <code>Optional[float]</code> <p>Maximum duration to process in seconds (None = full file)</p> <code>None</code> <code>clip_start</code> <code>Optional[float]</code> <p>Optional start time (seconds) to trim from beginning of audio</p> <code>None</code> <code>clip_end</code> <code>Optional[float]</code> <p>Optional end time (seconds) to stop processing; must be &gt; clip_start</p> <code>None</code> <code>clip_pad_seconds</code> <code>Union[float, str, None]</code> <p>Extra context (seconds) to include on each side of the clip before the STFT; the spectrogram is trimmed back to the target window. Use 'auto' to pad by half the window length (helps reduce edge artifacts).</p> <code>'auto'</code> <code>backend</code> <code>str</code> <p>'auto' (default), 'torch', or 'scipy' backend for spectrogram computation</p> <code>'auto'</code> <code>torch_device</code> <code>str</code> <p>Torch device for spectrogram computation ('cpu', 'cuda', or 'auto')</p> <code>'cpu'</code> <code>scaling</code> <code>str</code> <p>'density' (default) or 'spectrum' scaling for PSD normalization</p> <code>'density'</code> <code>quiet</code> <code>bool</code> <p>If True, suppress logger noise (only minimal prints for progress bar)</p> <code>False</code> <code>use_logging</code> <code>bool</code> <p>If False, fall back to stdout printing (avoids notebook logging friction)</p> <code>True</code>"},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.backend","title":"<code>backend = backend</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.clim","title":"<code>clim = clim</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.clip_end","title":"<code>clip_end = clip_end</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.clip_pad_seconds","title":"<code>clip_pad_seconds = clip_pad_seconds</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.clip_start","title":"<code>clip_start = clip_start</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.colormap","title":"<code>colormap = colormap</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.crop_freq_lims","title":"<code>crop_freq_lims = crop_freq_lims</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.freq_lims","title":"<code>freq_lims = freq_lims</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.hop_length","title":"<code>hop_length = hop_length</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.log","title":"<code>log = logger if use_logging else PrintLogger()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.log_freq","title":"<code>log_freq = log_freq</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.max_duration","title":"<code>max_duration = max_duration</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.nfft","title":"<code>nfft = nfft</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.overlap","title":"<code>overlap = overlap</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.quiet","title":"<code>quiet = quiet</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.scaling","title":"<code>scaling = scaling</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.torch_device","title":"<code>torch_device = torch_device</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.win_dur","title":"<code>win_dur = win_dur</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.win_length","title":"<code>win_length = win_length</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.window_type","title":"<code>window_type = window_type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator._apply_freq_lims","title":"<code>_apply_freq_lims(frequencies, power_spectrogram, power_db_norm)</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator._describe_window_type","title":"<code>_describe_window_type()</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator._resolve_clip_pad_seconds","title":"<code>_resolve_clip_pad_seconds(sample_rate)</code>","text":"<p>Resolve clip_pad_seconds, supporting an 'auto' mode.</p>"},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator._resolve_fft_params","title":"<code>_resolve_fft_params(sample_rate)</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator._resolve_window","title":"<code>_resolve_window(win_length)</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator._sanitize_metadata_for_mat","title":"<code>_sanitize_metadata_for_mat(value)</code>  <code>staticmethod</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator._torch_window_spec","title":"<code>_torch_window_spec()</code>","text":""},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.compute_spectrogram","title":"<code>compute_spectrogram(audio_data, sample_rate, clip_meta=None)</code>","text":"<p>Compute spectrogram following MATLAB implementation.</p> <p>Parameters:</p> Name Type Description Default <code>audio_data</code> <code>ndarray</code> <p>Audio signal</p> required <code>sample_rate</code> <code>int</code> <p>Sample rate in Hz</p> required <code>clip_meta</code> <code>Optional[dict]</code> <p>Optional clip metadata to trim spectrogram to target window</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray, ndarray]</code> <p>Tuple of (frequencies, times, power_spectrogram, normalized_db)</p>"},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.load_audio","title":"<code>load_audio(audio_path)</code>","text":"<p>Load audio file supporting multiple formats.</p> <p>Parameters:</p> Name Type Description Default <code>audio_path</code> <code>Union[str, Path]</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, int, Optional[dict]]</code> <p>Tuple of (audio_data, sample_rate, clip_meta)</p>"},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.plot_spectrogram","title":"<code>plot_spectrogram(frequencies, times, power_db_norm, title='Spectrogram', save_path=None)</code>","text":"<p>Plot spectrogram following MATLAB visualization.</p> <p>Parameters:</p> Name Type Description Default <code>frequencies</code> <code>ndarray</code> <p>Frequency array</p> required <code>times</code> <code>ndarray</code> <p>Time array</p> required <code>power_db_norm</code> <code>ndarray</code> <p>Normalized power in dB</p> required <code>title</code> <code>str</code> <p>Plot title</p> <code>'Spectrogram'</code> <code>save_path</code> <code>Optional[Union[str, Path]]</code> <p>Optional path to save plot</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>matplotlib Figure object</p>"},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.process_directory","title":"<code>process_directory(input_dir, save_dir, file_extensions=['.wav', '.flac', '.mp3', '.m4a'], save_plot=True, save_mat=True, save_npy=False)</code>","text":"<p>Process all audio files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>Union[str, Path]</code> <p>Directory containing audio files.</p> required <code>save_dir</code> <code>Union[str, Path]</code> <p>Directory to save outputs.</p> required <code>file_extensions</code> <code>List[str]</code> <p>Audio file extensions to include.</p> <code>['.wav', '.flac', '.mp3', '.m4a']</code> <code>save_plot</code> <code>bool</code> <p>Save PNG plots (default: True).</p> <code>True</code> <code>save_mat</code> <code>bool</code> <p>Save MATLAB <code>.mat</code> files (default: True).</p> <code>True</code> <code>save_npy</code> <code>bool</code> <p>Save NumPy <code>.npy</code> files (default: False).</p> <code>False</code> <p>Returns:</p> Type Description <code>List[dict]</code> <p>List of processing result dicts (one per file).</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the input directory does not exist.</p>"},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.process_single_file","title":"<code>process_single_file(audio_path, save_dir, save_plot=True, save_mat=True, save_npy=False, extra_metadata=None)</code>","text":"<p>Process a single audio file and generate a spectrogram.</p> <p>Parameters:</p> Name Type Description Default <code>audio_path</code> <code>Union[str, Path]</code> <p>Path to the input audio file.</p> required <code>save_dir</code> <code>Union[str, Path]</code> <p>Output directory for generated files.</p> required <code>save_plot</code> <code>bool</code> <p>Save a PNG plot (default: True).</p> <code>True</code> <code>save_mat</code> <code>bool</code> <p>Save MATLAB <code>.mat</code> output (default: True).</p> <code>True</code> <code>save_npy</code> <code>bool</code> <p>Save NumPy <code>.npy</code> output (default: False). The payload is a dict with <code>F</code>, <code>T</code>, <code>P</code>, <code>PdB_norm</code>, and metadata.</p> <code>False</code> <code>extra_metadata</code> <code>Optional[dict]</code> <p>Optional extra metadata to store in outputs.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dict with file paths, arrays, and metadata. Keys include:</p> <code>dict</code> <p><code>audio_file</code>, <code>frequencies</code>, <code>times</code>, <code>power_spectrogram</code>,</p> <code>dict</code> <p><code>power_db_norm</code>, <code>sample_rate</code>, <code>duration</code>, <code>metadata</code>,</p> <code>dict</code> <p>and any saved file paths (<code>mat_file</code>, <code>png_file</code>, <code>npy_file</code>).</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the audio file does not exist.</p> Example <pre><code>generator = SpectrogramGenerator(win_dur=0.5, overlap=0.5)\nresult = generator.process_single_file(\n    \"example.flac\",\n    \"./out\",\n    save_mat=True,\n    save_png=False,\n)\nprint(result[\"mat_file\"])\n</code></pre>"},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.save_matlab_format","title":"<code>save_matlab_format(frequencies, times, power_spectrogram, power_db_norm, save_path, metadata=None)</code>","text":"<p>Save spectrogram data in MATLAB format.</p> <p>Parameters:</p> Name Type Description Default <code>frequencies</code> <code>ndarray</code> <p>Frequency array</p> required <code>times</code> <code>ndarray</code> <p>Time array  </p> required <code>power_spectrogram</code> <code>ndarray</code> <p>Raw power spectrogram</p> required <code>power_db_norm</code> <code>ndarray</code> <p>Normalized power in dB</p> required <code>save_path</code> <code>Union[str, Path]</code> <p>Path to save .mat file</p> required"},{"location":"reference/spectrogram_generator/#onc_hydrophone_data.audio.spectrogram_generator.SpectrogramGenerator.save_numpy_format","title":"<code>save_numpy_format(frequencies, times, power_spectrogram, power_db_norm, save_path, metadata=None)</code>","text":"<p>Save spectrogram data in numpy format.</p> Notes <p>This uses np.save with a dict payload (requires allow_pickle on load). Metadata is stored under the \"metadata\" key when provided.</p>"}]}